{"posts":[{"title":"近期的一些总结","content":"大三下刚刚考试完，保研名额基本确定了吧，想想自己努力的几年，也总算是没有白费。 在疫情期间参加了上海科技大学，中科院光电所的夏令营，也都拿到了Offer，现在在等华中科技大学的结果，唯一有点遗憾的是没能多报一些夏令营，给自己的选择多一点。 感觉自己身上最大的缺点是心理素质不行，一到关键的时候就容易紧张，以后还要多多锻炼。 最近就在等最后几门课程的成绩出来，这个过程着实有点煎熬~~ 先这样，等学校确定之后再更新。 以后会定时写博客，希望大家关注，有想交流的小伙伴可以联系我的邮箱 ieLuHanJin@foxmail.com。 ","link":"https://dreamfixer.top/jin-qi-de-yi-xie-zong-jie/"},{"title":"开源项目——智能收纳系统","content":"这个项目做了挺久的，在此开源，致敬开源！ 智能收纳系统 项目完成的主要功能就是在树莓派本地端选择箱子进行物体的识别，本地端随后把识别的信息传给小程序端的云数据库，小程序端完成信息的储存以及展示，展示的视频随后会在下方给出，该项目可以完美解决人们日常生活中物品多、杂、乱的问题。 主要技术 该项目用到的几个主要模块： 物品的识别：前期我们借助于百度AI进行识别，后期我们用 Yolo 训练了一个人工神经网络，感觉效果应该是后边的好一些。 拍摄图片的储存及上传：利用 Nginx 图片服务器进行储存，其中 Nginx 服务器的搭建过程中遇到了不少坑，大多数是关于路径的问题；上传直接采用的是 Python 的 FTP 模块。 本地端与小程序端的交互：利用 Python 调用小程序端的 SDK 接口，其中有很多需要注意的地方，在网上能找到的资料也比较少，我们当时也是调试了很长时间。 小程序端的信息展示：这个相对来说简单一点，不过要想做的美观，需要有良好的 UI 设计能力。 效果展示 等待更新~~ ","link":"https://dreamfixer.top/kai-yuan-xiang-mu-zhi-neng-shou-na-xi-tong/"},{"title":"奇异值分解与特征值分解的理解","content":"奇异值 奇异值分解的类比 奇异值分解，就是把矩阵分成多个“分力”。 让我们通过翻绳来形象地理解。 我们可认为，这个造型是由两个方向的力合成的。 容易想象，如果其中一个力比较小的话，那么绳子的形状基本由另一个力来决定。 奇异值分解的数学表达 对于一个矩阵A，我们总能找到一个正交矩阵U和一个正交矩阵V ，以及一个对角矩阵Σ，使得X=UΣVTX = UΣV^TX=UΣVT。（其中U被称为X的左奇异向量，V被称为X的右奇异向量，而对角矩阵Σ的主对角线上的值称为矩阵X的奇异值，并按照从大到小降序排列。） 奇异值分解的几何解释 考虑矩阵A= 我们将通过单位圆这个载体来观察矩阵A对应的变换。 把单位圆上的每一点都通过A进行变换，得到一个椭圆。 对A进行奇异值分解： 将A表示成2个分力相加的形式： 第一个分力作用在单位圆上的效果： 同理，第二个分力作用在单位圆上的效果： 因此，当这两个分力一起作用的时候，单位圆就转换成了上边所展示的椭圆。（可以想象，如果两个分力相差很大，单位圆将被映射成一条直线） 细心的小伙伴应该发现，上面的例子好像并没有体现奇异值分解里的正交性。 其实奇异值分解就是将矩阵行空间的一个标准正交基转换为该矩阵列空间的标准正交基，它包括了旋转、缩放等变换。 奇异值分解的物理解释 观察下面两幅图片， 第一幅图为随机生成的一幅256x256的图像，值都是在0-255之间。第二幅图为SVD分解之后的奇异值矩阵，颜色越亮，代表了值越大，也就是能量越大。因此SVD的过程就是通过变换，将原空间的能量重新聚集分配，在新的空间集中的过程，这就是SVD的物理意义。通过这个物理意义，我们可以做许多的应用，例如数据的压缩，图像的滤波，以及推荐算法等。 奇异值的一种计算方法 对于奇异值的定义式X=UΣVTX = UΣV^TX=UΣVT，我们分别左乘和右乘X矩阵的转置，发现得到了两个对角矩阵，其特征值即为原式对角矩阵中对角线上各值的平方，两个对角矩阵的特征向量即为所求的U和V，具体可以自己推导，比较简单。 我是从MIT的OpenCourse的一节课学的，在网易公开课可以找到相应视频。 奇异值与特征值的区别与联系 特征值分解和奇异值分解都是给定一个线性变换，找一组特殊的基，特征值分解所对应的基即为特征向量，它只适用于对称正定矩阵，而奇异值对矩阵没有限制。（目前觉得自己的理解还停留在表面，没有更深层次的挖掘） 奇异值分解和特征值分解的应用先不说了，因为我还在本科，只是先对这一部分的知识有一个大体了解，以后具体用到哪部分再看。 本文结束，感谢阅读~~ ","link":"https://dreamfixer.top/qi-yi-zhi-fen-jie-yu-te-zheng-zhi-fen-jie-de-li-jie/"},{"title":"矩阵的基础知识","content":"由于大一学习的线性代数现在已经忘记得差不多了😥，因此在这里记录一下矩阵的常用知识，为以后更复杂的数学运算打下基础。 Hermitian矩阵与矩阵的二次型 Hermitian矩阵就是我们常说的复共轭对称矩阵，它是满足AH=AA^H=AAH=A的正方复矩阵。 任意一个正方对称矩阵A的二次型定义为xHAxx^HAxxHAx，其中x可以是任意的非零复向量。（需注意，这里A必须为实对称矩阵或复共轭对称矩阵，，为了保证定义的唯一性） 从这里又延申出了以下定义： 一句话小结，矩阵的二次型刻画矩阵的正定性 行列式 一个n*n正方矩阵A的行列式记作det(A)det(A)det(A)，A去掉第i行和第j列的剩余行列式记作AijA_{ij}Aij​，称为元素aija_{ij}aij​的余子式，从这里我们引出了行列式的计算公式： det(A)=ai1Ai1+......+ainAin=∑i=1naij(−1)i+jdet(Aij)det(A) = a_{i1}A_{i1}+......+a_{in}A_{in} = \\sum_{i=1}^{n}a_{ij}(-1)^{i+j}det(A_{ij})det(A)=ai1​Ai1​+......+ain​Ain​=∑i=1n​aij​(−1)i+jdet(Aij​)(即通过递推的方法计算) 关于行列式有以下几点说明： 行列式不等于0的矩阵称为非奇异矩阵。 单位矩阵的行列式等于1. 任何一个正方矩阵A和它的转置矩阵具有相同的行列式。 两个矩阵乘积的行列式等于它们的行列式的乘积。 一句话小结，矩阵的行列式主要刻画矩阵的奇异性。 矩阵的特征值 A为n*n的方阵，若线性代数方程： Au = λ∗u\\lambda*uλ∗u具有n*1非零向量解u，则标量λ\\lambdaλ称为矩阵A的一个特征值，u称为A对应于λ\\lambdaλ的特征向量。 这里特征值可以这样理解，英文叫做eigenvalue，词头Eigen有本征、固有的意思，因此eigenvalue表示矩阵A在不改变某些向量固有方向的基础上，对向量只进行长度λ\\lambdaλ倍的变换，因此λ\\lambdaλ就是矩阵A能将这些向量进行保留“本征”变换的倍数值。 通过特征值的定义，我们也可以将它和矩阵的奇异性、正定性和对角线元素结构联系起来，反映了矩阵的一些重要特征。 一句话小结，矩阵的特征值既刻画原矩阵的奇异性，又反映原矩阵所有对角元素的结构，还刻画矩阵的正定性。 矩阵的迹 n*n矩阵A的对角元素之和称为A的迹，记作tr(A)tr(A)tr(A)。（非正方矩阵无迹的定义） 这里有如下重要结论： 矩阵的迹等于该矩阵所有特征值之和。 一句话小结，矩阵的迹反映矩阵所有特征值之和。 矩阵的秩 矩阵Am∗nA_{m*n}Am∗n​的秩定义为该矩阵中线性无关的行或列的数目，记作rank(A)rank(A)rank(A)。 一句话小结，矩阵的秩刻画矩阵行与行之间或者列与列之间的线性无关性，从而反映矩阵的满秩性或秩亏缺性。 本文结束，感谢阅读~~ ","link":"https://dreamfixer.top/ju-zhen-de-ji-chu-zhi-shi/"},{"title":"随机信号处理学习笔记（AR模型的Burg算法）","content":"虽然Levinson-Durbin递推算法解决了矩阵计算比较复杂的问题，但仍需要对信号的自相关函数进行估计，造成了一定的误差。由此引出了Burg算法，它不需要对自相关函数进行估计，可以直接由观测数据求解反射系数。 Burg算法 Burg算法是一种与预测误差格型滤波器密切相关的算法，它需要求解信号的前向预测误差和后向预测误差，其递推公式如下： 反射系数Km的计算公式如下： （这里特别要注意求和的上下界） AR模型中剩余的系数仍通过Levinson-Durbin递推算法中的递推公式来计算： Burg算法改进之处是递推过程建立在数据序列基础上，避免了序列的自相关函数的估计，它能够较为精确地分辨出频率非常接近的正弦信号，而且Burg算法保证预测误差滤波器总是最小相位的。 Burg算法的Matlab实现 首先确定采样点数和AR模型阶数，写出待估计信号。 按照上述Km的计算公式循环实现，其中各阶用到的预测误差用其递推公式实现，其余参数仍用Levinson-Durbin递推公式实现。 各阶的预测误差功率可以通过Levinson-Durbin递推公式计算，但也可以默认为1，只是差一个幅度的关系。 本文结束，感谢阅读🤠 ","link":"https://dreamfixer.top/sui-ji-xin-hao-chu-li-xue-xi-bi-ji-burg-suan-fa/"},{"title":"随机信号处理学习笔记（AR模型的Levinson-Durbin递推解法）","content":"从Yule_Work直接解AR模型虽然直观，但存在不少问题。一是随着AR模型阶数的提高，矩阵运算量较大的问题；还有一个是信号的自相关函数估计不准确仍然导致结果误差较大的问题。 Levinson-Durbin递推解法 通过给定阶数，找出Yule_Work方程的规律，推导出递推公式。 1阶AR模型Yule_Work方程如下： m阶AR模型Yule_Work方程如下： 其中km为反射系数，即m阶AR模型的第m个系数。 Levinson-Durbin递推解法的Matlab实现 前几步跟直接解Yule_Work方程完全一样，只是各参数的计算方法变了。 在求完信号的自相关函数后，我们就可以根据递推公式来求解AR模型的各个参数了。 后续步骤也类似，求出系统函数后利用相关卷积定理来估计输出信号的功率谱。 有些同学在看到递推公式时仿佛无从下手的感觉，可以试试这个方法。先进行程序的初始化，然后明确当前已知量和要求解的量，根据算法里描述的一步一步来，相信你最终可以独立写出正确的代码。😎 本文已结束，感谢阅读~~ ","link":"https://dreamfixer.top/sui-ji-xin-hao-chu-li-xue-xi-bi-ji/"},{"title":"随机信号处理学习笔记（AR模型的Yule_Walker方程）","content":"在随机信号处理中，我们不可避免地要估计信号的功率谱。但使用DFT的经典谱估计法有时误差较大，而且有旁瓣的干扰等现象，因此前人们研究出来了现代谱估计方法。 AR模型 AR模型的系统函数可以表示为： 我们的目的是想从AR过程中求出参数a和G，从而用相关卷积定理估计出输出信号的功率谱。 Yule_Work方程 推导出Yule_Work方程的思路有很多，其中一种是利用最小均方误差准则。 Yule_Work方程的矩阵形式： 也可以写做： Yule_Work方程的Matlab实现 观察上述方程，我们基本上就可以得出程序实现的基本思路。 确定采样点数和AR模型阶数，写出待估计信号。 写出信号的自相关函数。 根据Yule_Work方程写出方程的增广矩阵，即方程两边的系数矩阵。(注，这里的自相关矩阵是托普利兹阵，matlab中有对应的toeplitz函数) 根据方程写出G^2，求出AR方程的系统函数。 利用相关卷积定理，写出信号的功率谱估计。 代码由于课程原因暂不放上去，请大家理解😉，后续会更新。 本文已结束，感谢阅读⛳️ ","link":"https://dreamfixer.top/sui-ji-xin-hao-chu-li-xue-xi-bi-ji-yule_walker-fang-cheng/"},{"title":"DSPF2812的理论学习（事件管理器EV、ADC和CMD命令文件）","content":"接上篇文章 DSPF2812的理论学习(CPU、时钟与中断) | 靳路晗~中国 事件管理器EV 使用DSP进行开发，事件管理器通常是要用到的，DSPF2812共有2个事件管理器EVA和EVB，它为用户提供了众多的功能，使其在电机控制、变频器、逆变器等应用场合中显得特别有用。EV模块包含通用定时器、比较单元、捕获单元、正交编码电路，下面将一 一介绍。 通用定时器 事件管理器EVA有通用定时器T1和T2，EVB有通用定时器T3和T4。通用定时器的作用主要有三： 计时。 使用定时器的比较功能产生PWM波。 也可以给事件管理器的其它模块提供基准时钟。 下面以T1为例，详细介绍通用定时器的工作原理。 首先来看通用定时器的结构： 从这张图中我们能得出以下信息： 和定时器T1相关的常用寄存器有：16位的T1周期寄存器T1PR；16位的T1比较寄存器T1CMPR；16位的T1计数寄存器T1CNT；16位的T1控制寄存器T1CON；16位的通用定时器控制寄存器GPTCONA。 定时器T1的输入信号：来自于CPU的内部时钟HSPCLK；外部时钟输入TCLKINA，最大频率不能超过37.5MHz；定时器计数方向输入TDIRA，用于定时器工作于定向增/减计数模式；复位信号。 定时器T1的输出信号：定时器的比较输出T1PWM_T1CMP，可输出PWM波；送给ADC模块的AD转换启动信号；下溢、上溢、比较和周期匹配信号，用于提供自身比较逻辑。 了解了这些，我们可以开始学习定时器的计数模式了。 T1共支持4种模式，由T1控制寄存器的第12位TMODE1和第11位TMODE0来选择。 当TMODE的值为0时，定时器T1工作于停止/保持模式。在这种模式下，T1停止计数并保持当前的状态。 当TMODE的值为1时，定时器T1工作于连续增/减计数模式。在这种模式下，T1计数器寄存器T1CNT先从初始值开始递增至周期寄存器的值，再递减至0，再递增，再递减，这样不断循环下去。 当TMODE的值为2时，定时器T1工作于连续递增计数模式。在这种模式下，T1计数器寄存器先从初始值开始递增至周期寄存器的值，然后突变为0，再从0开始递增至周期寄存器的值，不断重复循环下去。 当TMODE的值为3时，T1工作于定向增/减计数模式，这时候T1计数器寄存器进行递增或者递减计数取决于引脚TDIRA的电平（高电平递增，低电平递减）。如果在T1定时器计数寄存器计数过程中，引脚TDIRA的电平发生了变化，那么必须在完成当前计数周期后的下一个定时器时钟周期时，T1CNT的计数方向发生变化。 在以上四种模式中，我们用得最多的是连续增/减计数模式和连续递增计数模式，大家可以重点关注这两种。接下来我们将讨论PWM波的产生。 当T1计数器寄存器T1CNT和比较寄存器T1CMPR的值相等时，如果定时器的比较功能和比较输出使能，则T1PWM_T1CMP引脚就会输出PWM波形。定时器T1能够产生两种类型的PWM，不对称的和对称的。 当T1CNT工作于连续递增计数模式时，输出不对称的PWM波形。此时PWM波中各参数计算如下： 当T1CNT工作于连续增/减计数模式时，输出对称的PWM波形。 此时PWM中各参数计算如下： 大家可以根据上述公式快速计算PWM的参数。 比较单元与PWM电路 事件管理器EVA模块具有3个全比较单元，比较单元1、比较单元2、比较单元3。EVA的比较单元时钟信号由通用定时器T1来提供，每个比较单元都能够输出2路互补的PWM波形（在这里PWM波形的原理和定时器产生PWM的原理基本相同），也可以通过相应的寄存器来设置死区时间，因此它有能力去驱动一个三相全桥电路。 注意这里引入了一个死区概念，我通过下面的图来解释。 由图可以看出，输入开关管的PWM信号必须都是互补的。在理想情况下，PHa1是高电平时，PHa2是低电平。但是二者从高电平转换到低电平或从低电平转换为高电平时都需要一段时间，在这段时间内，二者会同时导通，否则将会被击穿。因此，我们要保证上下两管的上升沿和下降沿互相要隔开一段时间，这段时间就称为死区。 捕获单元与正交脉冲编码电路 捕获单元用于捕获输入引脚上的信号跳变。EV有6个捕获单元，其中EVA对应CAP1、CAP2、CAP3，EVB对应CAP4、CAP5、CAP6。每个捕获单元都有相应的捕获输入引脚，此外，正交脉冲编码电路与捕获输入单元共用芯片外部引脚。 F2812事件管理器的每个捕获单元都有一个专用的2级深度的FIFO堆栈，捕获单元被使能后，当输入引脚CAPx上有1一个跳变（由CAPCONA/B指定是检测上升沿还是下降沿），就将所选通用定时器的当前计数值载入到相应的FIFO栈中。同时相应的中断标志被置位，如果该中断未被屏蔽，就产生了一个外部中断请求，即发生了捕获事件。 每个事件管理器有一个正交脉冲编码电路QEP，EVA的QEP电路有输入引脚CAP1_QEP1、CAP2_QEP2，EVB的QEP电路有输入引脚CAP4_QEP3、CAP5_QEP4，光电码盘输出的两路正交编码信号正好从上述的两个输入引脚输入到DSP的QEP电路，然后再通过QEP的译码器对正交编码信号进行译码，最后就可以得到电机转子的转速、旋转方向、旋转位置等信息了。 QEP电路工作时，引脚CAP1_QEP1和引脚CAP2_QEP2输入两路正交编码脉冲，QEP电路对这两路正交编码脉冲的上升沿和下降沿都进行计数，因此QEP电路为定时器T2所提供的时钟频率是每个输入序列的4倍。 模/数转换器ADC F2812的ADC模块一共具有16个采样通道，分成两组：一组为ADCINA0-ADCINA7，另一组为ADCINB0-ADCINB7。具体结构见下图： 可以看出，虽然ADC模块具有多个输入通道，但内部只有一个转换器，因此同一时刻只能对一路输入信号进行转换。若某一时刻输入了多个信号，则ADC内部具有自动序列发生器，用户可以通过编程为序列发生器指定需要转换的通道顺序。 ADC的转换特性一般通过下面公式求得： ADC模块的时钟通过下式计算： ADC模块的通道采样时间如下： （其中ACQ_PS是ADC控制寄存器中的位） 下面开始说ADC的工作模式。 双序列发生器模式下顺序采样，假设对ADCINA0-ADCINA7、ADCINB0-ADCINB7这16路通道进行采样，此时将会用到序列发生器SEQ1和SEQ2。由于是顺序采样，必须对16个通道每一个通道进行排序。因此SEQ1将用到通道选择控制寄存器ADCCHSELSEQ1、ADCCHSELSEQ2，SEQ2将用到通道选择控制寄存器ADCCHSELSEQ3、ADCCHSELSEQ4。 双序列发生器模式下并发采样，仍然遵循上述假设，以下同。（并发采样是一对通道一对通道地采样）因此同样用到两个序列发生器，但此时只需要对一对通道中的任何一个通道进行排序即可，因此通道选择控制器使用的数量是顺序采样的一半。 级联模式下的顺序采样，由于ADC工作于级联模式，此时序列发生器SEQ1和SEQ2级联成了一个16状态的序列发生器SEQ。其它与双序列发生器模式下顺序采样类似。 级联模式下的并发采样，即级联模式与并发采样的组合。 以上就是DSPF2812中ADC的基础知识，实际想编程的话光看上边是做不了的，你还需要结合相应的寄存器去搞清楚每一位是干什么的，根据你的要求进行配置。 CMD命令文件 这里首先要介绍通用目标文件格式COFF，详细的COFF文件格式包括断头、可执行代码、初始化数据、可重定位信息、行号入口、符号表等等，但从应用的角度来看，我们只需要掌握两点：一是通过伪指令定义段，二是给段分配空间。 编译器处理段的过程：1. 把每个源文件都编译成独立的目标文件。 2. 链接器把目标文件中相同段名的部分链接在一起，生成最终的可执行文件。 首先来看下面一个CMD文件： MEMORY伪指令可以让用户选择目标存储器的起始地址和长度，其中PAGE0为程序空间，PAGE1为数据空间。 再来看下面的CMD文件： 其中，SECTIONS伪指令具体规定了在存储器内何处放置输出段，如果用户没有指定SECTIONS伪指令，链接器则用默认的算法组合并定位段。 对于CMD文件，我们主要是理解其对代码的分配，起到更好的管理存储空间的作用。如果代码量小且没有特殊要求的话，你也可以用默认的段分配方法。 本文结束，感谢阅读😘 ","link":"https://dreamfixer.top/dspf2812-de-li-lun-xue-xi-shi-jian-guan-li-qi-ev/"},{"title":"DSPF2812的理论学习(CPU、时钟与中断)","content":"随着大规模集成电路、数字计算机等技术的飞速发展，DSP系统逐渐流行起来，而我由于课程原因也接触到了DSP系统，因此在这里记录了DSPF2812的理论知识，为后续的编程打下基础。 DSP芯片的特点 哈佛结构：不同于传统的冯诺依曼结构，将程序和数据存储在不同的存储空间当中，因此取指和执行能完全重叠运行。 流水线操作：可以并行处理多条指令，减少了指令执行的时间。 专用的硬件乘法器：大大提高运算速度。 特殊的DSPs指令：可以执行许多复杂功能。 快速的指令周期：满足高实时性场合的需求。 这里DSPF2812的各引脚功能不再阐述，有兴趣的读者可参考TI公司的中文数据手册。 至于DSP应如何学习，我的老师把DSP的知识点抽象为建筑物的结构，我觉得很形象，大家可以参考一下。 CPU的内部结构和时钟 CPU 这里，我们首先要对CPU 有一个整体上的认识，见下图： 然后我们对CPU进行拆解，对CPU内部的结构有一个总览： 对于CPU，我觉得了解了以上知识就足够了，以后在编程中如果需要用到的话，再回来查找即可。 时钟综述 接着，我们需要学习微机中最重要的部分——时钟系统，而F2812需要处理大量的复杂运算，因此对定时的要求更加严格。而配置相应的时钟是通过修改对应的寄存器来完成的，主要有： 外设时钟控制寄存器（PCLKCR），控制片上各种时钟的工作状态，使能或禁止相关外设时钟。 系统控制和状态寄存器（SCSR），包含看门狗溢出位和看门狗中断使能/屏蔽位，和看门狗的控制有关。 高低速外设时钟设置寄存器（HISPCP/LOSPCP) ，用于设置不同速度的外设。 晶体振荡器和锁相环 F2812片上有基于PLL的时钟模块，为器件及各种外设提供时钟信号。 其中，系统的时钟源由外部XPLLDIS引脚确定，当该引脚为低电平时，系统直接采用晶振作为系统时钟；当该引脚为高电平时，外部时钟经过PLL倍频后，为系统提供时钟。 若要改变锁相环的工作模式及倍频的系数，可以通过锁相环控制寄存器来修改。 CPU定时器 F2812共有3个32位CPU定时器(TIMER0/1/2)，其中后两个预留给实时操作系统使用，用户只可以使用定时器0。其中三个定时器的中断信号分别为TINT0, TINT1, TINT2，分别对应于中断向量INT1，INT13，INT14。 接下来将CPU定时器的具体原理，请读者仔细阅读。 简单来说，定时器就像闹钟，定时器工作前一般要经历以下几个步骤： 首先给周期寄存器PRDH:PRD赋值（这里是用2个16位寄存器来表示一个32位寄存器），当启动定时器开始计数时，周期寄存器的值装载进定时器计数寄存器TIMH:TIM中。 好比闹钟每隔1s走动一下一样，计数器寄存器里面的值每隔一个TIMCLK就减1，直到计数到0，定时器完成一个周期的计数，这时将产生一个中断信号。 TIMCLK的值又从何而来呢，它由定时器分频器TDDRH:TDDR和定时器预定标器PSCH:PSC来控制。先给定时器分频器赋值，然后装载入定时器预定标器，这样每隔一个SYSCLKOUT脉冲，预定标器中的值就减1.直到减为0时，就输出一个TIMCLK。 经过以上的分析，我们容易得出定时器周期的计算公式。 看门狗电路 在由MCU构成的微型计算机系统中，由于单片机的工作常常会受到外界电磁场的干扰，造成程序跑飞而陷入死循环，会造成整个系统陷入停滞状态，因此有了看门狗电路的产生。 我们可以这样来理解F2812的看门狗电路原理F2812的看门狗电路有一个8位看门狗加法计数器WDCNTR，无论什么时候，如果该计算器达到最大值，看门狗模块就会产生一个输出脉冲使系统复位。为了防止WDCNTR溢出，通常采用2种方法。 禁止看门狗。 定期“喂狗”，即通过软件向负责复位看门狗计数器的看门狗密钥寄存器周期性地写入0x55+0xAA。 （这里需要注意的是逻辑校验位是看门狗的另一个安全机制，所有访问看门狗控制寄存器WDCR的写操作中，相应的校验位必须是101，否则将会拒绝访问并立即触发系统复位。） 存储器与通用I/O口 F2812存储器的映射见下图： 其中，相信大家对各种片内存储器的优点都有了解，在这里我们仅对外部扩展接口进行介绍。 外部扩展接口XINTF F2812的外部接口XINTF映射到5个独立的区域，见下图： 当访问相应的存储区域时，会产生一个片选信号。此外，从图上可以看出，有的区域共用一个片选信号。 这一部分我觉得跟后续的编程不太相关，所以我的学习方法是大概浏览几遍，用到再去查。 GPIO多路复用器 在F2812处理器当中，相当一部分引脚是外设和数字I/O引脚公用的。它们通过 GPxMUX 寄存器来配置选择具体的引脚功能(作为外设或数字 I/O 引脚)。当引脚作为数字I/O时，可以通过方向控制寄存器GPxDIR控制I/O的方向，是作为输入还是输出，并可以通过量化寄存器GPxQUAL量化输入信号，消除外部噪声信号。 同上边一样，我不会深入设计具体寄存器每一位的功能，因为这些是不用记的，知道如何操作就行。 中断管理 这里讲下中断的作用，通过软件或硬件激发的中断请求信号，可以使CPU暂停目前执行的主程序，转而去执行中断服务程序，以便CPU实现数据的传送或接收。 F2812的中断主要有两种方式触发：一种是在软件中写指令；另一种是硬件方式触发。无论是软件中断还是硬件中断，都可归结为可屏蔽中断和不可屏蔽中断。 以下我们将重点讨论可屏蔽中断和PIE中断，暂时不考虑不可屏蔽中断。 中断向量和优先级 F2812一共可以支持32个CPU中断，其中每一个中断都是一个32位的中断向量，但里面存储的是22位的中断服务程序的入口地址，CPU将优先处理优先级高的中断 。 可屏蔽中断 可屏蔽中断有3个专用寄存器的支持，中断标志寄存器IFR，中断使能寄存器IER和调试中断使能寄存器DBGIER。IFR中包含的相应标志位表面对应中断在等待CPU的响应，IER和DBGIER则控制使能或屏蔽某一可屏蔽中断，其中后一寄存器用于实时仿真。 可屏蔽中断的响应过程是：首先当某个可屏蔽中断提出请求时，IFR中的中断标志位自动置位。接着CPU将检查IER中相应位的值和是否使能了全局中断。若以上都没有问题，则CPU将会响应该中断，暂停主程序并转向执行相应的中断服务子程序。 外设中断扩展模块PIE PIE是为了使F2812CPU能够管理更多的中断而设计的，PIE中多个中断源复用一个CPU中断，这些中断被分为12组，每个组有8个中断，每个组都被反馈到CPU内核的12条中断信号线的一条上，因此PIE共可支持96个中断，具体管理的中断源见下图： 对于PIE中断，内部具体是如何复用的，硬件电路是如何连接的，我们不必关心，最重要的是看懂外设中断在PIE中是如何分布的： 这里同组内，排在前边的中断优先级比排在后面中断优先级的高，而不同组之间，排在前面组的任何一个中断优先级要比排在后面组内的任何一个中断的优先级高。 可屏蔽CPU中断可以通过中断使能寄存器和中断标志寄存器来进行编程控制，同样，PIE的每个组都有3个相关的寄存器，分别是PIE中断使能寄存器PIEIERx，PIE中断标志寄存器PIEIFRx和PIE中断应答寄存器PIEACKx，其中x代表组号。 中断的编程 这里我们以中断为例，介绍实际编程中的步骤。 首先在外设初始化函数中使能外设中断。 主函数里初始化外设、使能PIE和CPU中断等。 在DSP28_DefaultIsr.c里编写你的中断处理函数，这里需要注意应该手动清除外设中断的标志位和复位PIE应答寄存器PIEACK相关的位，使得CPU能够响应PIE控制器同组内的其它中断。 本文结束，感谢阅读~😁 ","link":"https://dreamfixer.top/dspf2812-de-li-lun-xue-xi/"},{"title":"解决pip安装Python库时：ReadTimeoutError","content":"近来Python不知怎的就被墙了，据说是有一个非法网站跟Python的网站很像，本来想禁那个非法网站的，结果~~😢😢😢 所以我们如果再用pip安装Python的某些库时，就会出现连接不上的问题。 解决办法 指定国内的下载源来进行下载，把原来的安装命令替换为： pip install -i https://pypi.douban.com/simple 需要安装的Python库 试了试，速度还挺快的。😁 本文已结束，感谢阅读~~ ","link":"https://dreamfixer.top/jie-jue-pip-an-zhuang-python-ku-shi-readtimeouterror/"},{"title":"树莓派上CSI摄像头的使用","content":"由于工程设计要用到树莓派的摄像头进行识别操作，本文将使用Python+OpenCV+Raspi 3B+ 来完成树莓派CSI摄像头的配置使用，以及后续的扩展操作（树莓派照相机）。 CSI摄像头的连接 将排线的接口查在树莓派上的对应位置即可，如下图。 在树莓派上使能摄像头功能 一般有两种方法，在这里我们采用一种博主认为比较方便的方法。 在命令行中输入： $ sudo raspi-config 然后在【Enable Camera】一栏里，设置为TRUE即可，此时树莓派要重启哦。 摄像头的调试 测试摄像头是否能够正常使用，这时候我们可以利用Raspberry Pi给我们的raspistill来验证是否能够使用。 $ raspistill -o test.jpg 在/home/目录下会生成test.jpg文件，同时会出现摄像头的画面。 利用Python库操作摄像头 这里，如果你想直接用OpenCV来 操作摄像头，需进行如下设置（因为树莓派中的camera module是放在/boot/目录中以固件形式加载的，不是一个标准的V4L2的摄像头驱动）： sudo nano /etc/modules 添加一行：bcm2835-v4l2 保存退出，重启树莓派，这时就可直接用OpenCV来直接操作摄像头啦（未测试是否有bug），这里默认读者在此前已经接触过OpenCV了🤗。 如果你不想进行上述设置，可以采用下边的方法。在命令行输入： $ pip install picamera 安装成功后，我们可以新建一个Python文件，输入以下代码测试（用摄像头拍摄一张照片）： from picamera.array import PiRGBArray from picamera import PiCamera import time import cv2 ​ camera = PiCamera() rawCapture = PiRGBArray(camera) time.sleep(0.1) camera.capture(rawCapture, format=&quot;bgr&quot;) image = rawCapture.array cv2.imshow(&quot;Image&quot;, image) cv2.waitKey(0) 获取视频流的代码： from picamera.array import PiRGBArray from picamera import PiCamera import time import cv2 camera = PiCamera() camera.resolution = (640, 480) camera.framerate = 32 rawCapture = PiRGBArray(camera) time.sleep(0.1) # 获取图片 for frame in camera.capture_continuous(rawCapture, format=&quot;bgr&quot;, use_video_port=True): image = frame.array # 显示 cv2.imshow(&quot;Frame&quot;, image) key = cv2.waitKey(1) &amp; 0xFF # 清空缓存 rawCapture.truncate(0) # 如果按到键盘字母'q'就退出循环 if key == ord(&quot;q&quot;): break 以上就是CSI摄像头的基本操作哦，如果你想通过触摸屏来做一个基于树莓派的照相机，给大家提供一个基本思路，用QTDesigner结合Python的PYQT5库来设计~~ 本文结束，感谢阅读~~ ","link":"https://dreamfixer.top/shu-mei-pai-shang-csi-she-xiang-tou-de-shi-yong-geng-xin-zhong/"},{"title":"2019全国大学生电赛总结（附视觉代码）","content":"本文记录了参加2019年全国大学生电子竞赛的一些体会。 准备过程😬 暑假期间，我和我们组的两个人一起在学校集中进行全国大学生电子竞赛的培训，虽然整个过程很苦，但是能取得省级二等奖的成绩（去测试的时候失误了~~在学校打得挺准的），也算是有一点回报吧。 我是负责视觉设计的，也帮写程序的同学想想控制算法，最后会附上我们的视觉程序供大家来学习。 一些体会👇 比赛过程中，三个人一定要配合好，各自把自己的任务干好，还有就是坚决不要放弃，我们就是比赛的最后一天才把电磁炮做出来，然后赶紧测试，晚上8点之前交作品还是绰绰有余的。 电赛找到一个好的指导老师非常关键，无论是在知识上还是精神上，都能够给你提供帮助。我们的指导老师就很好，整个过程陪着我们，帮我们想方案，帮我们找问题，看到他就觉得安心。 下边是我们的视觉代码，有兴趣的可以参考一下。 import sensor, image, time, pyb from pyb import UART from struct import pack import math ​ sensor.reset() sensor.set_pixformat(sensor.RGB565) sensor.set_framesize(sensor.QVGA) sensor.set_brightness(0) #sensor.skip_frames(10) sensor.set_auto_whitebal(False) clock = time.clock() # 追踪帧率 ​ ​ uart = UART(3, 115200) ​ fx = 279.4808 #.4808 fy = 279.4204 #.4204 cx = 133.6368 cy = 123.6917 ​ K = 5120 buf_d = [0,0,0,0,0] ​ ​ BLACK = (0, 43, -12, 4, -10, 9) BALL = (23, 97, 48, 127, -37, 62) ​ img = sensor.snapshot() black_blobs = img.find_blobs([BLACK], pixels_threshold=9000) board_roi = (1,1,500,500) ball_blobs = img.find_blobs([BALL], roi=board_roi, pixels_threshold=100, merge=True, margin=1) ​ if ball_blobs: for ball_blob in ball_blobs: img.draw_rectangle(ball_blob[0:4]) img.draw_cross(ball_blob[5], ball_blob[6], size=50) if black_blobs: for black_blob in black_blobs: img.draw_rectangle(board_roi[0:4]) ​ def find_max(blobs): max_size=0 for blob in blobs: if blob.pixels() &gt; max_size: max_blob=blob max_size = blob.pixels() return max_blob ​ ​ while(True): frame_fps =clock.fps() ​ img = sensor.snapshot() ball_blobs = img.find_blobs([BALL], roi=board_roi, pixels_threshold=100, merge=True, margin=1) ​ if ball_blobs: max_blob = find_max(ball_blobs) target_x = 135 target_y = 120 ​ img.draw_rectangle(max_blob.rect()) # rect img.draw_cross(max_blob.cx(), max_blob.cy()) # cx, cy #print(max_blob.cx(),max_blob.cy()) ​ yaw = math.atan((max_blob.cx() - cx) / fx) - math.atan((target_x - cx) / fx) pitch = math.atan((max_blob.cy() - cy) / fy) - math.atan((target_y - cy) / fy) #print(math.atan((last_x - cx) / fx)) #print(&quot;yaw: &quot;, yaw) #print(&quot;pitch: &quot;, pitch) yaw*=180/3.141592 pitch*=180/3.141592 ​ buf_d[0] = K / ((max_blob.w()+max_blob.h())/2) buf_d[4]=buf_d[3];buf_d[3]=buf_d[2];buf_d[2]=buf_d[1];buf_d[1]=buf_d[0]; D_buf=sorted(buf_d) D = D_buf[2] ​ print(&quot;yaw: &quot;, yaw) print(&quot;pitch: &quot;, pitch) print(&quot;Dis:&quot;, D) D = K/max_blob.w() #K = max_blob.w()*128 #print(K) #print(D) datap = pack('bbbbfffbb',0x35,0x46,0x57,0x24, float(yaw), float(pitch), float(D), 0xBB, 0xAA) print('you send:',datap) uart.write(datap) 基本的思路非常简单，找到最大的红色块，然后通过小孔成像原理算出来舵机需要变换的角度。 写在最后🎃 虽然没能取得好的成绩，但是整个过程我觉得自己提升不少，希望自己能再接再厉，争取下一次取得更好的成绩！ 对了，补充一点，去测试的过程心态一定要放平，还有就是最后一刻一定不要动结构！！！我们就是吃了这个的亏~~ 本文结束，感谢阅读！ ","link":"https://dreamfixer.top/2019-quan-guo-da-xue-sheng-dian-sai-zong-jie/"},{"title":"BHuman框架的基本配置及简单使用","content":"BHuman框架是当今Robocup标准平台组比赛的主流框架，本文介绍了BHuman框架的一些最基本的操作。 镜像以及各种包的安装 依次运行以下代码： sudo ./installAlcommon naoqi-sdk-2.1.4.13-linux32.tar.gz的位置 //注意需要先到网盘里下载naoqi-sdk，位置在share/Nao sudo apt install clang qtbase5-dev libqt5svg5-dev libglew-dev libxml2-dev graphviz xterm 进行编译 从根目录进入 Make/Linux，打开终端，输入命令make即可（若提示权限不够，输入sudo make)。 为Nao创建机器人配置文件 进入Install目录，依次输入以下命令: ./ createRobot -t 队伍编号 -r 机器人编号 机器人名字 //举例 ./ createRobot -t 71 -r 1 ZZU-ONE ./ addRobotIds - ip 169.254.54.28 刚才创建的机器人名字 //注意此时需改变有线网络下的IPV4配置，依次点击ipv4-手动，输入IP地址为Nao机器人报的IP地址，网关统一为255.255.0.0 ./ installRobot 机器人的IP //注意这一步需要到Make/Linux目录操作 接下来，我们需再次更改IPV4那里的ip地址，为192.168.71.254，保持网关不变，然后输入命令: ./ copyfiles Develop 刚才更改的IP地址 -t 71 -c blue -p 机器人编号 -b 到此步，机器人的配置基本完成,可以打开Bush进行验证，位置如下图: 代码结构 BHuman的代码框架还是挺大的，但我们重点关注的是Config和Src这两个文件夹，Config里边是基本的参数文件配置，在Src里边我们主要编写5个机器人的策略和上场的策略，如果有能力的话，可以试着修改一下底层文件，加入我们自己的特色。（注意每次编写完代码后都需要进入Make/Linux重新编译） 如何仿真 仿真程序的位置如下： 打开之后，我们需要选择一个场景文件，选择之后，点击Robocup会出现比赛的仿真界面，这时我们打开console，输入gc playing可以控制比赛的开始，还有很多其它命令，可参考CodeRelease2017的SimRobot那一章，机器人选项那里是机器人的各种参数的信息，在那里我们可以调节机器人的视觉参数以改善机器人的定位，效果如下： 注：（我认为调节守门员时球门前边的十字线非常重要，对于前锋来说，中圈的识别非常重要，这是他们定位的主要依据） 🤗本文结束，谢谢阅读！ ","link":"https://dreamfixer.top/bhuman-kuang-jia-de-ji-ben-pei-zhi-ji-jian-dan-shi-yong/"},{"title":"Huffman编码——Python实现","content":"Huffman编码简介 1952年，哈夫曼提出了一种构造最佳码的方法称为哈夫曼码（也有说霍夫曼码，看你怎么翻译了）。它充分利用了信源概率分布的特性进行编码，是无失真信源编码方法的一种。 具体编码方法，看下面的演示即可。 Python实现 根据Python面向对象编程的特点，我们可以先构思出2个大类，一个为节点类，另一个为哈夫曼树类，利用节点来完成哈夫曼树的建立。 😬节点类代码如下： #节点类 class Node(object): def __init__(self,name=None,value=None): self._name=name self._value=value self._left=None self._right=None 🤒接着，我们用哈夫曼树的编码思想，利用节点反向建立哈夫曼树。 #哈夫曼树类 class HuffmanTree(object): #根据Huffman树的思想：以节点为基础，反向建立Huffman树 def __init__(self,char_weights): self.Leav=[Node(part[0],part[1]) for part in char_weights] #根据输入的字符及其频数生成节点 while len(self.Leav)!=1: self.Leav.sort(key=lambda node:node._value,reverse=True) c=Node(value=(self.Leav[-1]._value+self.Leav[-2]._value)) c._left=self.Leav.pop(-1) c._right=self.Leav.pop(-1) self.Leav.append(c) self.root=self.Leav[0] self.Buffer=list(range(10)) 🤐建立完哈夫曼树后，我们遍历整个树，将左边的节点给0，右边的节点给1，这里采用递归的思想。 #用递归的思想生成编码 def pre(self,tree,length): node=tree if (not node): return elif node._name: print (node._name + ' encoding:',end=''), for i in range(length): print (self.Buffer[i],end='') print ('\\n') return self.Buffer[length]=0 self.pre(node._left,length+1) self.Buffer[length]=1 self.pre(node._right,length+1) #生成哈夫曼编码 def get_code(self): self.pre(self.root,0) 结果 😷测试代码如下： if __name__=='__main__': #输入的是字符及其频数 char_weights=[('a',6),('b',4),('c',10),('d',8),('f',12),('g',2)] tree=HuffmanTree(char_weights) tree.get_code(） 结果图: 🤡本文结束，感谢阅读！ ","link":"https://dreamfixer.top/huffman-bian-ma-python-shi-xian/"},{"title":"关于","content":" 欢迎来到我的小站呀，很高兴遇见你！🤝 🏠 关于本站 😁本站主要创作一些博主学习过程中的一些心得和比赛的总结，会定期更新，欢迎大家收藏！ 👨‍💻 博主是谁 😎大家好，我是郑州大学通信工程专业的一名在读本科生，是郑州大学双足实验室NAO组的队员，也是ZZU-DROID 2019年参赛队员，负责视觉与定位方向。 ⛹ 兴趣爱好 😀喜欢打篮球，喜欢数学 📬 联系我呀 🤓 Email：LuHanJin.Study@outlook.com Github: https://github.com/angleHan 知乎：https://www.zhihu.com/people/meng-xiang-75-23-61 ","link":"https://dreamfixer.top/about/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://dreamfixer.top/hello-gridea/"}]}